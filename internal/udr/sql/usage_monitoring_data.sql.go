// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: usage_monitoring_data.sql

package sql

import (
	"context"
)

const deleteUsageMonData = `-- name: DeleteUsageMonData :exec
DELETE FROM usage_mon_data
WHERE ue_id = ? AND limit_id = ?
`

type DeleteUsageMonDataParams struct {
	UeID    string
	LimitID string
}

func (q *Queries) DeleteUsageMonData(ctx context.Context, arg DeleteUsageMonDataParams) error {
	_, err := q.db.ExecContext(ctx, deleteUsageMonData, arg.UeID, arg.LimitID)
	return err
}

const getUsageMonitoringData = `-- name: GetUsageMonitoringData :one
SELECT ue_id, limit_id, um_level, allowed_usage, reset_time
FROM usage_mon_data
WHERE ue_id = ? AND limit_id = ?
`

type GetUsageMonitoringDataParams struct {
	UeID    string
	LimitID string
}

type GetUsageMonitoringDataRow struct {
	UeID         string
	LimitID      string
	UmLevel      string
	AllowedUsage string
	ResetTime    string
}

func (q *Queries) GetUsageMonitoringData(ctx context.Context, arg GetUsageMonitoringDataParams) (GetUsageMonitoringDataRow, error) {
	row := q.db.QueryRowContext(ctx, getUsageMonitoringData, arg.UeID, arg.LimitID)
	var i GetUsageMonitoringDataRow
	err := row.Scan(
		&i.UeID,
		&i.LimitID,
		&i.UmLevel,
		&i.AllowedUsage,
		&i.ResetTime,
	)
	return i, err
}

const getUsageMonitoringDataById = `-- name: GetUsageMonitoringDataById :one
SELECT id, ue_id, limit_id, um_level, allowed_usage, reset_time
FROM usage_mon_data
WHERE id = ?
`

type GetUsageMonitoringDataByIdRow struct {
	ID           int64
	UeID         string
	LimitID      string
	UmLevel      string
	AllowedUsage string
	ResetTime    string
}

func (q *Queries) GetUsageMonitoringDataById(ctx context.Context, id int64) (GetUsageMonitoringDataByIdRow, error) {
	row := q.db.QueryRowContext(ctx, getUsageMonitoringDataById, id)
	var i GetUsageMonitoringDataByIdRow
	err := row.Scan(
		&i.ID,
		&i.UeID,
		&i.LimitID,
		&i.UmLevel,
		&i.AllowedUsage,
		&i.ResetTime,
	)
	return i, err
}

const getUsageMonitoringDataByUeID = `-- name: GetUsageMonitoringDataByUeID :many
SELECT id, ue_id, limit_id, um_level, allowed_usage, reset_time
FROM usage_mon_data
WHERE ue_id = ?
`

type GetUsageMonitoringDataByUeIDRow struct {
	ID           int64
	UeID         string
	LimitID      string
	UmLevel      string
	AllowedUsage string
	ResetTime    string
}

func (q *Queries) GetUsageMonitoringDataByUeID(ctx context.Context, ueID string) ([]GetUsageMonitoringDataByUeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getUsageMonitoringDataByUeID, ueID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsageMonitoringDataByUeIDRow
	for rows.Next() {
		var i GetUsageMonitoringDataByUeIDRow
		if err := rows.Scan(
			&i.ID,
			&i.UeID,
			&i.LimitID,
			&i.UmLevel,
			&i.AllowedUsage,
			&i.ResetTime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertOrUpdateUsageMonData = `-- name: InsertOrUpdateUsageMonData :exec
INSERT INTO usage_mon_data (ue_id, limit_id, um_level, allowed_usage, reset_time)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT (ue_id, limit_id)
DO UPDATE SET 
    um_level = excluded.um_level,
    allowed_usage = excluded.allowed_usage,
    reset_time = excluded.reset_time,
    updated_at = CURRENT_TIMESTAMP
`

type InsertOrUpdateUsageMonDataParams struct {
	UeID         string
	LimitID      string
	UmLevel      string
	AllowedUsage string
	ResetTime    string
}

func (q *Queries) InsertOrUpdateUsageMonData(ctx context.Context, arg InsertOrUpdateUsageMonDataParams) error {
	_, err := q.db.ExecContext(ctx, insertOrUpdateUsageMonData,
		arg.UeID,
		arg.LimitID,
		arg.UmLevel,
		arg.AllowedUsage,
		arg.ResetTime,
	)
	return err
}
